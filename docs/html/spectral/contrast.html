<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.8.1" />
<title>spectral.contrast API documentation</title>
<meta name="description" content="Module for contrasting timeseries data based on their spectral properties …" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spectral.contrast</code></h1>
</header>
<section id="section-intro">
<p>Module for contrasting timeseries data based on their spectral properties.</p>
<p>The set of methods are aimed at finding the frequency bands that enable the maximal seperability betwen two sets of timeseries data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module for contrasting timeseries data based on their spectral properties.

The set of methods are aimed at finding the frequency bands that enable the maximal seperability betwen two sets of timeseries data.
&#34;&#34;&#34;

# IMPORT DEPENDENCIES

from __future__ import absolute_import, print_function
import numpy as np
from scipy import signal
from spectral.data_handling import Dataset, TsParams, DataArray

# Code starts here
def contrast(ds: Dataset, y: list, debug=False, **kwargs):
    &#34;&#34;&#34;
    This method returns the SNR given a data array and vector of labels.
    
    Ideally, this should be the only method that you need to call when contrasting timeseries&#39; spectra.
    
    Parameters
    ----------
    ds: Dataset object
        an instance of `spectral.data_handling.Dataset` containing LFP data and relevant parameters for signal processing.
    y: list [ntrials]
        a binary vector with a label for each trial being either 0 or 1
        
    **DEBUG: param (bool)
        Flag for printing debugging output
        
    Returns
    -------
    snr: array [nfreqs x nfreqs]
        a matrix with the SNR for each combination of frequency bands starting from lowest frequency in f to the highest.
        The first axis represents the start band the second axis represents the stop band.
    f: array [nfreqs]
        a vector that represents the frequencies for interpreting `snr`.
    &#34;&#34;&#34;

    # Read params from the Dataset passed to the method
    fs, nperseg, noverlap = ds.data_array.fs, ds.params.nperseg, ds.params.noverlap

    y = np.array(y)

    # convert input to numpy array (precautionarily)
    data = ds.data_array.data

    # get normalization array
    if debug:
        print(&#34;Obtain normalization array...&#34;)
    norm = get_norm_array(data, fs=fs, nperseg=nperseg, noverlap=noverlap)

    # decompose data
    if debug:
        print(&#34;calculating stft...&#34;)
    ds, f = get_stft(
        data, norm_array=norm, normalize=True, fs=fs, nperseg=nperseg, noverlap=noverlap
    )

    # compute mean power over every permutation of bands
    if debug:
        print(&#34;normalizing matrices... this may take a few minutes...&#34;)
    t, b = get_bands(ds[:, :, :, y == 1], ds[:, :, :, y == 0], f, **kwargs)

    # calculate the snr
    if debug:
        print(&#34;obtaining snr...&#34;)
    snr = get_snr(t, b)

    # Return the correct vector f
    fmin = int(kwargs[&#34;fmin&#34;]) if &#34;fmin&#34; in kwargs else min(f)
    fmax = int(kwargs[&#34;fmax&#34;]) if &#34;fmax&#34; in kwargs else max(f)
    fidx = [i for i in range(len(f)) if f[i] &gt;= fmin and f[i] &lt;= fmax]
    f = f[fidx]

    return snr, f


def get_norm_array(data: np.ndarray, fs=100, nperseg=64, noverlap=48, **kwargs):
    &#34;&#34;&#34;
    Returns the normalization array for timeseries data.
    
    Parameters
    ----------
    data: array, timeseries data [nchan x nobs x ntrials]
    fs: int, sampling frequency in Hz
    nperseg: int, number of timepoints for stft window
    noverlap: int, number of timepoints for window overlap

    Returns
    -------
    norm_array: normalized array with mean power per frequency [nchan x freqs]
    &#34;&#34;&#34;

    # Get the STFT of the signals
    f, _, data_stft = signal.stft(
        data, fs=fs, nperseg=nperseg, noverlap=noverlap, axis=1
    )

    data_stft = np.moveaxis(np.abs(data_stft), 2, 3)  # last axis is now ntrials
    data_stft = data_stft[:, :, 1:-1, :]  # purge STFT flanks

    # Average across trials and time-bins
    data_stft_mean = np.mean(np.abs(data_stft), axis=-1)  # trials
    norm_array = np.mean(np.abs(data_stft_mean), axis=-1)  # timebins

    return norm_array


def get_stft(data_array, norm_array=[], normalize=True, **kwargs):
    &#34;&#34;&#34;
    Returns the STFT for timeseries data.
    
    Parameters
    -----------
    data_array: array
        timeseries data [nchan x nobs x ntrials]
    norm_array: array
        for spectral normalization (see `get_norm_array()`)
    *fs: int
        sampling frequency in Hz
    *nperseg: int
        number of timepoints for stft window
    *noverlap: int
        number of timepoints for window overlap
        
    Returns
    -------
    stft_array: array
        STFT of the input array [nchan x nfreqs x nobs x trials]
    f: array
        an array of the frequencies of the STFT transform
    &#34;&#34;&#34;
    # Read stft params from function arguments
    if &#34;fs&#34; in kwargs:
        fs = int(kwargs[&#34;fs&#34;])
    else:
        fs = 100

    if &#34;nperseg&#34; in kwargs:
        nperseg = int(kwargs[&#34;nperseg&#34;])
    else:
        nperseg = 64

    if &#34;noverlap&#34; in kwargs:
        noverlap = int(kwargs[&#34;noverlap&#34;])
    else:
        noverlap = 3 * (nperseg // 4)

    # Calculate the short-time fourrier transform
    f, _, data_stft = signal.stft(
        data_array,
        fs=fs,
        nperseg=nperseg,
        noverlap=noverlap,
        axis=1,
        detrend=&#34;constant&#34;,
    )

    # Make last axis as trials
    data_stft = np.moveaxis(np.abs(data_stft), 2, 3)
    data_stft = data_stft[:, :, 1:-1, :]

    if normalize:
        # Facilitate vectorized division
        norm_array_data = np.repeat(
            norm_array[:, :, np.newaxis], data_stft.shape[-2], axis=-1
        )
        norm_array_data = np.repeat(
            norm_array_data[:, :, :, np.newaxis], data_stft.shape[-1], axis=-1
        )

        # Normalize the spectrograms for calculating SNR
        data_stft_norm = data_stft / norm_array_data

        return data_stft_norm, f

    else:
        return data_stft, f


def get_bands(target_stft_norm, baseline_stft_norm, f, **kwargs):
    &#34;&#34;&#34;
    Calculates the mean power across all possible combinations of frequencies for each channel.
    
    Parameters
    ----------
    target_stft_norm: array
        stft decomposed target array [nchan x nfreqs x nobs x ntrials]
    baseline_stft_norm: array
        stft decomposed baseline array [nchan x nfreqs x nobs x ntrials]
    f: array
        vector of frequencies obtained from STFT transform (see `get_stft()`).
    
    Returns
    -------
    target_bands: array
        array of mean power across all possible band permutations [nchan x nfreqs x nfreqs x nobs x ntrials]
    baseline_bands: array
        same as `target_bands` [nchan x nfreqs x nfreqs x nobs x ntrials]
    &#34;&#34;&#34;

    fmin = int(kwargs[&#34;fmin&#34;]) if &#34;fmin&#34; in kwargs else min(f)
    fmax = int(kwargs[&#34;fmax&#34;]) if &#34;fmax&#34; in kwargs else max(f)
    fidx = [i for i in range(len(f)) if f[i] &gt;= fmin and f[i] &lt;= fmax]
    f = f[fidx]
    fnum = len(f)

    data_array_norm = np.array(target_stft_norm[:, fidx, :, :])
    baseline_array_norm = np.array(baseline_stft_norm[:, fidx, :, :])

    band_tot = np.empty(
        (
            fnum,
            fnum,
            data_array_norm.shape[0],
            data_array_norm.shape[2],
            data_array_norm.shape[3],
        )
    )
    band_tot_bl = np.empty(
        (
            fnum,
            fnum,
            baseline_array_norm.shape[0],
            baseline_array_norm.shape[2],
            baseline_array_norm.shape[3],
        )
    )

    band_tot[:] = np.nan
    band_tot_bl[:] = np.nan

    for i in range(fnum):
        for j in range(fnum):
            if j &gt; i:
                idx = (f &gt;= f[i]) &amp; (f &lt; f[j])

                band_tot[i, j, :, :] = np.sum(data_array_norm[:, idx, :, :], axis=1) / (
                    f[j] - f[i]
                )
                band_tot_bl[i, j, :, :] = np.sum(
                    baseline_array_norm[:, idx, :, :], axis=1
                ) / (f[j] - f[i])

    band_tot_bl1 = np.mean(band_tot_bl, axis=3)  # average across time bins
    band_tot_bl2 = np.repeat(
        band_tot_bl1[:, :, :, None, :], band_tot_bl.shape[3], axis=3
    )  # repeat same value across time
    return band_tot, band_tot_bl2


def get_snr(target, baseline):
    &#34;&#34;&#34;
    Returns the SNR given two vectors: target and baseline.
    
    Parameters
    ----------
    target: array [nchan x nfreqs x nfreqs x nobs x ntrials]
        an array obtained by using `get_bands()`
    
    baseline: array (same as target)

    Returns
    -------
    snr: array [nfreqs x nfreqs]
        a lower triangular matix representing the contrast between bands
    &#34;&#34;&#34;

    mu_cue = np.mean(target, axis=-1)  # average accross trials
    mu_bl = np.mean(baseline, axis=-1)  # average accross trials
    std_cue = np.std(target, axis=-1)  # average accross trials
    std_bl = np.std(baseline, axis=-1)  # average accross trials

    snr = np.abs(_div0((mu_cue - mu_bl), (std_cue + std_bl)))
    snr2 = np.nanmax(snr, axis=-1)
    if snr2.shape[0] == snr.shape[1]:
        snr2 = np.nanmax(snr2, axis=-1)

    return snr2


def _div0(a, b):
    &#34;&#34;&#34;ignore / 0, div0( [-1, 0, 1], 0 ) -&gt; [0, 0, 0] &#34;&#34;&#34;
    with np.errstate(divide=&#34;ignore&#34;, invalid=&#34;ignore&#34;):
        c = np.true_divide(a, b)
        c[~np.isfinite(c)] = 0  # -inf inf NaN
    return c


def decimate(x, n, **kwargs):
    &#34;&#34;&#34;
    Downsample the data in a data array by a factor of n.
    
    Parameters
    ----------
    x: data array [nchan x nobs x ntrials]
        the data array to be analyzed.
    
    n: int
        the downsampling factor

    Returns
    -------
    data_dec: array [nchan x nobs/n x ntrials]
        downsampled array
    &#34;&#34;&#34;

    data_dec = signal.decimate(x, n, axis=1)
    return data_dec


def __get_f_from_idx(idx, f):
    &#34;&#34;&#34;
    Returns the value of f from the index
    
    Parameters
    ----------
    
    idx: array 
        array with indices for which frequencies are required
        
    Returns
    -------
    f: array
        array with frequencies corresponding to idx
    
    &#34;&#34;&#34;

    return [f[i] for i in idx]


def test():
    &#34;&#34;&#34;
    Simple test method to ensure that the pipeline and dependencies work.
    
    Returns `True` if everything works.
    &#34;&#34;&#34;
    params = TsParams(nperseg=64, noverlap=48)
    da = DataArray(fs=1000, nchannels=10, ntrials=10, simulate=True)
    ds = Dataset(da, params)

    ds.data_array.data = decimate(ds.data_array.data, 10)

    y = np.ones((ds.data_array.data.shape[-1]))
    y[2:] = 0

    snr, _ = contrast(ds, y, fs=100, nperseg=64, noverlap=48)
    snr2, _ = contrast(ds, y)

    return np.allclose(snr, snr2)


def filter(data, low_pass, high_pass, fs, order=4):
    &#34;&#34;&#34;
    Generates an n-th order butterworth filter and performs forward-backward pass on the signal.
    
    Parameters
    ----------
    data: array
        same as data structure [nchans x nobs x ntrials]
    low_pass: param
        low pass frequency
    high_pass: param
        high pass frequency
    fs: param
        sampling frequency
    order: param
        filter order
        
    Returns
    -------
    filt_data: array
        array with same shape as `data` but bandpass filtered
    &#34;&#34;&#34;

    nyq = fs / 2
    low = low_pass / nyq
    high = high_pass / nyq
    b, a = signal.butter(order, [low, high], btype=&#34;band&#34;)
    filt_data = signal.filtfilt(b, a, data, axis=1, method=&#34;gust&#34;)
    return filt_data


if __name__ == &#34;__main__&#34;:
    test()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spectral.contrast.contrast"><code class="name flex">
<span>def <span class="ident">contrast</span></span>(<span>ds: <a title="spectral.data_handling.Dataset" href="data_handling.html#spectral.data_handling.Dataset">Dataset</a>, y: list, debug=False, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>This method returns the SNR given a data array and vector of labels.</p>
<p>Ideally, this should be the only method that you need to call when contrasting timeseries' spectra.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>ds</code></strong> :&ensp;<code>Dataset object</code></dt>
<dd>an instance of <code><a title="spectral.data_handling.Dataset" href="data_handling.html#spectral.data_handling.Dataset">Dataset</a></code> containing LFP data and relevant parameters for signal processing.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>list [ntrials]</code></dt>
<dd>a binary vector with a label for each trial being either 0 or 1</dd>
<dt><strong><code>**DEBUG</code></strong> :&ensp;<code>param (bool)</code></dt>
<dd>Flag for printing debugging output</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>snr</code></strong> :&ensp;<code>array [nfreqs x nfreqs]</code></dt>
<dd>a matrix with the SNR for each combination of frequency bands starting from lowest frequency in f to the highest.
The first axis represents the start band the second axis represents the stop band.</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>array [nfreqs]</code></dt>
<dd>a vector that represents the frequencies for interpreting <code>snr</code>.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contrast(ds: Dataset, y: list, debug=False, **kwargs):
    &#34;&#34;&#34;
    This method returns the SNR given a data array and vector of labels.
    
    Ideally, this should be the only method that you need to call when contrasting timeseries&#39; spectra.
    
    Parameters
    ----------
    ds: Dataset object
        an instance of `spectral.data_handling.Dataset` containing LFP data and relevant parameters for signal processing.
    y: list [ntrials]
        a binary vector with a label for each trial being either 0 or 1
        
    **DEBUG: param (bool)
        Flag for printing debugging output
        
    Returns
    -------
    snr: array [nfreqs x nfreqs]
        a matrix with the SNR for each combination of frequency bands starting from lowest frequency in f to the highest.
        The first axis represents the start band the second axis represents the stop band.
    f: array [nfreqs]
        a vector that represents the frequencies for interpreting `snr`.
    &#34;&#34;&#34;

    # Read params from the Dataset passed to the method
    fs, nperseg, noverlap = ds.data_array.fs, ds.params.nperseg, ds.params.noverlap

    y = np.array(y)

    # convert input to numpy array (precautionarily)
    data = ds.data_array.data

    # get normalization array
    if debug:
        print(&#34;Obtain normalization array...&#34;)
    norm = get_norm_array(data, fs=fs, nperseg=nperseg, noverlap=noverlap)

    # decompose data
    if debug:
        print(&#34;calculating stft...&#34;)
    ds, f = get_stft(
        data, norm_array=norm, normalize=True, fs=fs, nperseg=nperseg, noverlap=noverlap
    )

    # compute mean power over every permutation of bands
    if debug:
        print(&#34;normalizing matrices... this may take a few minutes...&#34;)
    t, b = get_bands(ds[:, :, :, y == 1], ds[:, :, :, y == 0], f, **kwargs)

    # calculate the snr
    if debug:
        print(&#34;obtaining snr...&#34;)
    snr = get_snr(t, b)

    # Return the correct vector f
    fmin = int(kwargs[&#34;fmin&#34;]) if &#34;fmin&#34; in kwargs else min(f)
    fmax = int(kwargs[&#34;fmax&#34;]) if &#34;fmax&#34; in kwargs else max(f)
    fidx = [i for i in range(len(f)) if f[i] &gt;= fmin and f[i] &lt;= fmax]
    f = f[fidx]

    return snr, f</code></pre>
</details>
</dd>
<dt id="spectral.contrast.decimate"><code class="name flex">
<span>def <span class="ident">decimate</span></span>(<span>x, n, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Downsample the data in a data array by a factor of n.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>x</code></strong> :&ensp;<code>data array [nchan x nobs x ntrials]</code></dt>
<dd>the data array to be analyzed.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>the downsampling factor</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>data_dec</code></strong> :&ensp;<code>array [nchan x nobs/n x ntrials]</code></dt>
<dd>downsampled array</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def decimate(x, n, **kwargs):
    &#34;&#34;&#34;
    Downsample the data in a data array by a factor of n.
    
    Parameters
    ----------
    x: data array [nchan x nobs x ntrials]
        the data array to be analyzed.
    
    n: int
        the downsampling factor

    Returns
    -------
    data_dec: array [nchan x nobs/n x ntrials]
        downsampled array
    &#34;&#34;&#34;

    data_dec = signal.decimate(x, n, axis=1)
    return data_dec</code></pre>
</details>
</dd>
<dt id="spectral.contrast.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>data, low_pass, high_pass, fs, order=4)</span>
</code></dt>
<dd>
<div class="desc"><p>Generates an n-th order butterworth filter and performs forward-backward pass on the signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array</code></dt>
<dd>same as data structure [nchans x nobs x ntrials]</dd>
<dt><strong><code>low_pass</code></strong> :&ensp;<code>param</code></dt>
<dd>low pass frequency</dd>
<dt><strong><code>high_pass</code></strong> :&ensp;<code>param</code></dt>
<dd>high pass frequency</dd>
<dt><strong><code>fs</code></strong> :&ensp;<code>param</code></dt>
<dd>sampling frequency</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>param</code></dt>
<dd>filter order</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filt_data</code></strong> :&ensp;<code>array</code></dt>
<dd>array with same shape as <code>data</code> but bandpass filtered</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(data, low_pass, high_pass, fs, order=4):
    &#34;&#34;&#34;
    Generates an n-th order butterworth filter and performs forward-backward pass on the signal.
    
    Parameters
    ----------
    data: array
        same as data structure [nchans x nobs x ntrials]
    low_pass: param
        low pass frequency
    high_pass: param
        high pass frequency
    fs: param
        sampling frequency
    order: param
        filter order
        
    Returns
    -------
    filt_data: array
        array with same shape as `data` but bandpass filtered
    &#34;&#34;&#34;

    nyq = fs / 2
    low = low_pass / nyq
    high = high_pass / nyq
    b, a = signal.butter(order, [low, high], btype=&#34;band&#34;)
    filt_data = signal.filtfilt(b, a, data, axis=1, method=&#34;gust&#34;)
    return filt_data</code></pre>
</details>
</dd>
<dt id="spectral.contrast.get_bands"><code class="name flex">
<span>def <span class="ident">get_bands</span></span>(<span>target_stft_norm, baseline_stft_norm, f, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculates the mean power across all possible combinations of frequencies for each channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>target_stft_norm</code></strong> :&ensp;<code>array</code></dt>
<dd>stft decomposed target array [nchan x nfreqs x nobs x ntrials]</dd>
<dt><strong><code>baseline_stft_norm</code></strong> :&ensp;<code>array</code></dt>
<dd>stft decomposed baseline array [nchan x nfreqs x nobs x ntrials]</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code></dt>
<dd>vector of frequencies obtained from STFT transform (see <code><a title="spectral.contrast.get_stft" href="#spectral.contrast.get_stft">get_stft()</a></code>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>target_bands</code></strong> :&ensp;<code>array</code></dt>
<dd>array of mean power across all possible band permutations [nchan x nfreqs x nfreqs x nobs x ntrials]</dd>
<dt><strong><code>baseline_bands</code></strong> :&ensp;<code>array</code></dt>
<dd>same as <code>target_bands</code> [nchan x nfreqs x nfreqs x nobs x ntrials]</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bands(target_stft_norm, baseline_stft_norm, f, **kwargs):
    &#34;&#34;&#34;
    Calculates the mean power across all possible combinations of frequencies for each channel.
    
    Parameters
    ----------
    target_stft_norm: array
        stft decomposed target array [nchan x nfreqs x nobs x ntrials]
    baseline_stft_norm: array
        stft decomposed baseline array [nchan x nfreqs x nobs x ntrials]
    f: array
        vector of frequencies obtained from STFT transform (see `get_stft()`).
    
    Returns
    -------
    target_bands: array
        array of mean power across all possible band permutations [nchan x nfreqs x nfreqs x nobs x ntrials]
    baseline_bands: array
        same as `target_bands` [nchan x nfreqs x nfreqs x nobs x ntrials]
    &#34;&#34;&#34;

    fmin = int(kwargs[&#34;fmin&#34;]) if &#34;fmin&#34; in kwargs else min(f)
    fmax = int(kwargs[&#34;fmax&#34;]) if &#34;fmax&#34; in kwargs else max(f)
    fidx = [i for i in range(len(f)) if f[i] &gt;= fmin and f[i] &lt;= fmax]
    f = f[fidx]
    fnum = len(f)

    data_array_norm = np.array(target_stft_norm[:, fidx, :, :])
    baseline_array_norm = np.array(baseline_stft_norm[:, fidx, :, :])

    band_tot = np.empty(
        (
            fnum,
            fnum,
            data_array_norm.shape[0],
            data_array_norm.shape[2],
            data_array_norm.shape[3],
        )
    )
    band_tot_bl = np.empty(
        (
            fnum,
            fnum,
            baseline_array_norm.shape[0],
            baseline_array_norm.shape[2],
            baseline_array_norm.shape[3],
        )
    )

    band_tot[:] = np.nan
    band_tot_bl[:] = np.nan

    for i in range(fnum):
        for j in range(fnum):
            if j &gt; i:
                idx = (f &gt;= f[i]) &amp; (f &lt; f[j])

                band_tot[i, j, :, :] = np.sum(data_array_norm[:, idx, :, :], axis=1) / (
                    f[j] - f[i]
                )
                band_tot_bl[i, j, :, :] = np.sum(
                    baseline_array_norm[:, idx, :, :], axis=1
                ) / (f[j] - f[i])

    band_tot_bl1 = np.mean(band_tot_bl, axis=3)  # average across time bins
    band_tot_bl2 = np.repeat(
        band_tot_bl1[:, :, :, None, :], band_tot_bl.shape[3], axis=3
    )  # repeat same value across time
    return band_tot, band_tot_bl2</code></pre>
</details>
</dd>
<dt id="spectral.contrast.get_norm_array"><code class="name flex">
<span>def <span class="ident">get_norm_array</span></span>(<span>data: numpy.ndarray, fs=100, nperseg=64, noverlap=48, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the normalization array for timeseries data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array, timeseries data [nchan x nobs x ntrials]</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fs</code></strong> :&ensp;<code>int, sampling frequency in Hz</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>nperseg</code></strong> :&ensp;<code>int, number</code> of <code>timepoints for stft window</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>noverlap</code></strong> :&ensp;<code>int, number</code> of <code>timepoints for window overlap</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>norm_array</code></strong> :&ensp;<code>normalized array with mean power per frequency [nchan x freqs]</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_norm_array(data: np.ndarray, fs=100, nperseg=64, noverlap=48, **kwargs):
    &#34;&#34;&#34;
    Returns the normalization array for timeseries data.
    
    Parameters
    ----------
    data: array, timeseries data [nchan x nobs x ntrials]
    fs: int, sampling frequency in Hz
    nperseg: int, number of timepoints for stft window
    noverlap: int, number of timepoints for window overlap

    Returns
    -------
    norm_array: normalized array with mean power per frequency [nchan x freqs]
    &#34;&#34;&#34;

    # Get the STFT of the signals
    f, _, data_stft = signal.stft(
        data, fs=fs, nperseg=nperseg, noverlap=noverlap, axis=1
    )

    data_stft = np.moveaxis(np.abs(data_stft), 2, 3)  # last axis is now ntrials
    data_stft = data_stft[:, :, 1:-1, :]  # purge STFT flanks

    # Average across trials and time-bins
    data_stft_mean = np.mean(np.abs(data_stft), axis=-1)  # trials
    norm_array = np.mean(np.abs(data_stft_mean), axis=-1)  # timebins

    return norm_array</code></pre>
</details>
</dd>
<dt id="spectral.contrast.get_snr"><code class="name flex">
<span>def <span class="ident">get_snr</span></span>(<span>target, baseline)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the SNR given two vectors: target and baseline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>target</code></strong> :&ensp;<code>array [nchan x nfreqs x nfreqs x nobs x ntrials]</code></dt>
<dd>an array obtained by using <code><a title="spectral.contrast.get_bands" href="#spectral.contrast.get_bands">get_bands()</a></code></dd>
<dt><strong><code>baseline</code></strong> :&ensp;<code>array (same as target)</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>snr</code></strong> :&ensp;<code>array [nfreqs x nfreqs]</code></dt>
<dd>a lower triangular matix representing the contrast between bands</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_snr(target, baseline):
    &#34;&#34;&#34;
    Returns the SNR given two vectors: target and baseline.
    
    Parameters
    ----------
    target: array [nchan x nfreqs x nfreqs x nobs x ntrials]
        an array obtained by using `get_bands()`
    
    baseline: array (same as target)

    Returns
    -------
    snr: array [nfreqs x nfreqs]
        a lower triangular matix representing the contrast between bands
    &#34;&#34;&#34;

    mu_cue = np.mean(target, axis=-1)  # average accross trials
    mu_bl = np.mean(baseline, axis=-1)  # average accross trials
    std_cue = np.std(target, axis=-1)  # average accross trials
    std_bl = np.std(baseline, axis=-1)  # average accross trials

    snr = np.abs(_div0((mu_cue - mu_bl), (std_cue + std_bl)))
    snr2 = np.nanmax(snr, axis=-1)
    if snr2.shape[0] == snr.shape[1]:
        snr2 = np.nanmax(snr2, axis=-1)

    return snr2</code></pre>
</details>
</dd>
<dt id="spectral.contrast.get_stft"><code class="name flex">
<span>def <span class="ident">get_stft</span></span>(<span>data_array, norm_array=[], normalize=True, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Returns the STFT for timeseries data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_array</code></strong> :&ensp;<code>array</code></dt>
<dd>timeseries data [nchan x nobs x ntrials]</dd>
<dt><strong><code>norm_array</code></strong> :&ensp;<code>array</code></dt>
<dd>for spectral normalization (see <code><a title="spectral.contrast.get_norm_array" href="#spectral.contrast.get_norm_array">get_norm_array()</a></code>)</dd>
<dt><strong><code>*fs</code></strong> :&ensp;<code>int</code></dt>
<dd>sampling frequency in Hz</dd>
<dt><strong><code>*nperseg</code></strong> :&ensp;<code>int</code></dt>
<dd>number of timepoints for stft window</dd>
<dt><strong><code>*noverlap</code></strong> :&ensp;<code>int</code></dt>
<dd>number of timepoints for window overlap</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>stft_array</code></strong> :&ensp;<code>array</code></dt>
<dd>STFT of the input array [nchan x nfreqs x nobs x trials]</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code></dt>
<dd>an array of the frequencies of the STFT transform</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stft(data_array, norm_array=[], normalize=True, **kwargs):
    &#34;&#34;&#34;
    Returns the STFT for timeseries data.
    
    Parameters
    -----------
    data_array: array
        timeseries data [nchan x nobs x ntrials]
    norm_array: array
        for spectral normalization (see `get_norm_array()`)
    *fs: int
        sampling frequency in Hz
    *nperseg: int
        number of timepoints for stft window
    *noverlap: int
        number of timepoints for window overlap
        
    Returns
    -------
    stft_array: array
        STFT of the input array [nchan x nfreqs x nobs x trials]
    f: array
        an array of the frequencies of the STFT transform
    &#34;&#34;&#34;
    # Read stft params from function arguments
    if &#34;fs&#34; in kwargs:
        fs = int(kwargs[&#34;fs&#34;])
    else:
        fs = 100

    if &#34;nperseg&#34; in kwargs:
        nperseg = int(kwargs[&#34;nperseg&#34;])
    else:
        nperseg = 64

    if &#34;noverlap&#34; in kwargs:
        noverlap = int(kwargs[&#34;noverlap&#34;])
    else:
        noverlap = 3 * (nperseg // 4)

    # Calculate the short-time fourrier transform
    f, _, data_stft = signal.stft(
        data_array,
        fs=fs,
        nperseg=nperseg,
        noverlap=noverlap,
        axis=1,
        detrend=&#34;constant&#34;,
    )

    # Make last axis as trials
    data_stft = np.moveaxis(np.abs(data_stft), 2, 3)
    data_stft = data_stft[:, :, 1:-1, :]

    if normalize:
        # Facilitate vectorized division
        norm_array_data = np.repeat(
            norm_array[:, :, np.newaxis], data_stft.shape[-2], axis=-1
        )
        norm_array_data = np.repeat(
            norm_array_data[:, :, :, np.newaxis], data_stft.shape[-1], axis=-1
        )

        # Normalize the spectrograms for calculating SNR
        data_stft_norm = data_stft / norm_array_data

        return data_stft_norm, f

    else:
        return data_stft, f</code></pre>
</details>
</dd>
<dt id="spectral.contrast.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Simple test method to ensure that the pipeline and dependencies work.</p>
<p>Returns <code>True</code> if everything works.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test():
    &#34;&#34;&#34;
    Simple test method to ensure that the pipeline and dependencies work.
    
    Returns `True` if everything works.
    &#34;&#34;&#34;
    params = TsParams(nperseg=64, noverlap=48)
    da = DataArray(fs=1000, nchannels=10, ntrials=10, simulate=True)
    ds = Dataset(da, params)

    ds.data_array.data = decimate(ds.data_array.data, 10)

    y = np.ones((ds.data_array.data.shape[-1]))
    y[2:] = 0

    snr, _ = contrast(ds, y, fs=100, nperseg=64, noverlap=48)
    snr2, _ = contrast(ds, y)

    return np.allclose(snr, snr2)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spectral" href="index.html">spectral</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="spectral.contrast.contrast" href="#spectral.contrast.contrast">contrast</a></code></li>
<li><code><a title="spectral.contrast.decimate" href="#spectral.contrast.decimate">decimate</a></code></li>
<li><code><a title="spectral.contrast.filter" href="#spectral.contrast.filter">filter</a></code></li>
<li><code><a title="spectral.contrast.get_bands" href="#spectral.contrast.get_bands">get_bands</a></code></li>
<li><code><a title="spectral.contrast.get_norm_array" href="#spectral.contrast.get_norm_array">get_norm_array</a></code></li>
<li><code><a title="spectral.contrast.get_snr" href="#spectral.contrast.get_snr">get_snr</a></code></li>
<li><code><a title="spectral.contrast.get_stft" href="#spectral.contrast.get_stft">get_stft</a></code></li>
<li><code><a title="spectral.contrast.test" href="#spectral.contrast.test">test</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.8.1</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>