<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.7.2" />
<title>spectral.contrast API documentation</title>
<meta name="description" content="Module for contrasting timeseries data based on their spectral properties â€¦" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>spectral.contrast</code></h1>
</header>
<section id="section-intro">
<p>Module for contrasting timeseries data based on their spectral properties.</p>
<p>The set of methods are aimed at finding the frequency bands that enable the maximal seperability betwen two sets of timeseries data.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Module for contrasting timeseries data based on their spectral properties.

The set of methods are aimed at finding the frequency bands that enable the maximal seperability betwen two sets of timeseries data.
&#34;&#34;&#34;

# IMPORT DEPENDENCIES

from __future__ import absolute_import, print_function
import numpy as np
from scipy import signal

# Code starts here
def get_norm_array(data, **kwargs):
    &#34;&#34;&#34;
    Returns the normalization array for timeseries data.
    
    Parameters
    ----------
    data: array, timeseries data [nchan x nobs x ntrials]
    *fs: int, sampling frequency in Hz
    *nperseg: int, number of timepoints for stft window
    *noverlap: int, number of timepoints for window overlap

    Returns
    -------
    norm_array: normalized array with mean power per frequency [nchan x freqs]
    &#34;&#34;&#34;

    # Read stft params from function arguments
    if &#39;fs&#39; in kwargs.items(): fs=kwargs[&#39;fs&#39;]
    else: fs = 1000

    if &#39;nperseg&#39; in kwargs.items(): noverlap=kwargs[&#39;nperseg&#39;]
    else: nperseg = 64

    if &#39;noverlap&#39; in kwargs.items(): noverlap=kwargs[&#39;noverlap&#39;]
    else: noverlap = 3*(nperseg//4)

    # Get the STFT of the signals
    f, _, data_stft = signal.stft(
        data, fs=fs, nperseg=nperseg, noverlap=noverlap, axis=1)

    data_stft = np.moveaxis(np.abs(data_stft), 2, 3)  # last axis is now ntrials
    data_stft = data_stft[:, :, 1:-1, :]              # purge STFT flanks

    # Average across trials and time-bins
    data_stft_mean = np.mean(np.abs(data_stft), axis=-1)    # trials
    norm_array = np.mean(np.abs(data_stft_mean), axis=-1)   # timebins

    return norm_array

def get_stft(data_array, norm_array=[], normalize=True, **kwargs):
    &#34;&#34;&#34;
    Returns the STFT for timeseries data.
    
    Parameters
    -----------
    data_array: array
        timeseries data [nchan x nobs x ntrials]
    norm_array: array
        for spectral normalization (see `get_norm_array()`)
    *fs: int
        sampling frequency in Hz
    *nperseg: int
        number of timepoints for stft window
    *noverlap: int
        number of timepoints for window overlap
        
    Returns
    -------
    stft_array: array
        STFT of the input array [nchan x nfreqs x nobs x trials]
    f: array
        an array of the frequencies of the STFT transform
    &#34;&#34;&#34;
    # Read stft params from function arguments
    if &#39;fs&#39; in kwargs.items(): fs=kwargs[&#39;fs&#39;]
    else: fs = 1000

    if &#39;nperseg&#39; in kwargs.items(): noverlap=kwargs[&#39;nperseg&#39;]
    else: nperseg = 64

    if &#39;noverlap&#39; in kwargs.items(): noverlap=kwargs[&#39;noverlap&#39;]
    else: noverlap = 3*(nperseg//4)

    # Calculate the short-time fourrier transform
    f, _, data_stft = signal.stft(
        data_array, fs=fs, nperseg=nperseg, noverlap=noverlap, axis=1)
    
    # Make last axis as trials
    data_stft = np.moveaxis(np.abs(data_stft), 2, 3)
    data_stft = data_stft[:,:,1:-1,:]

    if normalize:
        # Facilitate vectorized division
        norm_array_data = np.repeat(norm_array[:, :, np.newaxis], data_stft.shape[-2], axis=-1)
        norm_array_data = np.repeat(norm_array_data[:, :, :, np.newaxis], data_stft.shape[-1], axis=-1)

        # Normalize the spectrograms for calculating SNR
        data_stft_norm = data_stft / norm_array_data

        return data_stft_norm, f

    else:
        return data_stft, f

def get_bands(target_stft_norm, baseline_stft_norm, f):
    &#34;&#34;&#34;
    Calculates the mean power across all possible combinations of frequencies for each channel.
    
    Parameters
    ----------
    target_stft_norm: array
        stft decomposed target array [nchan x nfreqs x nobs x ntrials]
    baseline_stft_norm: array
        stft decomposed baseline array [nchan x nfreqs x nobs x ntrials]
    f: array
        vector of frequencies obtained from STFT transform (see `get_stft()`).
    
    Returns
    -------
    target_bands: array
        array of mean power across all possible band permutations [nchan x nfreqs x nfreqs x nobs x ntrials]
    baseline_bands: array
        same as `target_bands` [nchan x nfreqs x nfreqs x nobs x ntrials]
    &#34;&#34;&#34;
    
    data_array_norm = target_stft_norm
    baseline_array_norm = baseline_stft_norm

    fmax = 500
    fidx = f &lt; fmax
    fnum = f[fidx].size

    band_tot = np.zeros((fnum, fnum, data_array_norm.shape[0], data_array_norm.shape[2], data_array_norm.shape[3]))
    band_tot_bl = np.zeros((fnum, fnum, baseline_array_norm.shape[0], baseline_array_norm.shape[2], baseline_array_norm.shape[3]))
    for i in range(fnum):
        for j in range(fnum):
            if j &gt; i:
                idx = (f &gt;= f[i]) &amp; (f &lt; f[j])
                band_tot[i, j, :, :] = np.sum(data_array_norm[:, idx, :, :], axis=1) / (f[j] - f[i])
                band_tot_bl[i, j, :, :] = np.sum(baseline_array_norm[:, idx, :, :], axis=1) / (f[j] - f[i])


    band_tot_bl1 = np.mean(band_tot_bl, axis=3)     # average across time bins
    band_tot_bl2 = np.repeat(band_tot_bl1[:, :, :, None, :], band_tot_bl.shape[3], axis=3)    # repeat same value across time
    return band_tot, band_tot_bl2

def get_snr(target, baseline):
    &#34;&#34;&#34;
    Returns the SNR given two vectors: target and baseline.
    
    Parameters
    ----------
    target: array [nchan x nfreqs x nfreqs x nobs x ntrials]
        an array obtained by using `get_bands()`
    
    baseline: array (same as target)

    Returns
    -------
    snr: array [nfreqs x nfreqs]
        a lower triangular matix representing the contrast between bands
    &#34;&#34;&#34;

    mu_cue = np.mean(target, axis=-1)     # average accross trials
    mu_bl = np.mean(baseline, axis=-1)     # average accross trials
    std_cue = np.std(target, axis=-1)     # average accross trials
    std_bl = np.std(baseline, axis=-1)     # average accross trials

    snr = np.abs(_div0((mu_cue - mu_bl), (std_cue + std_bl)))
    snr2 = np.nanmax(snr, axis=-1)
    if snr2.shape[0] == snr.shape[1]:
        snr2 = np.nanmax(snr2, axis=-1)

    return snr2

def _div0( a, b ):
    &#34;&#34;&#34;ignore / 0, div0( [-1, 0, 1], 0 ) -&gt; [0, 0, 0] &#34;&#34;&#34;
    with np.errstate(divide=&#39;ignore&#39;, invalid=&#39;ignore&#39;):
        c = np.true_divide( a, b )
        c[ ~ np.isfinite( c )] = 0  # -inf inf NaN
    return c

def generate_ts(nsamples=10000, fs=1000, **kwargs):
    &#34;&#34;&#34;
    Generates a 10s long LFP-like timeseries at 1kHz obeying the power law.
    &#34;&#34;&#34;
    # For unit test
    if &#39;seed&#39; in kwargs.items(): np.random.seed=kwargs[&#39;seed&#39;]
   
    # Generate some pink noise
    t = np.arange(nsamples) # timesteps
    f = 2*np.pi*t/fs  # frequency (in radians)

    # generate random complex series
    n = np.zeros((nsamples,), dtype=complex)
    n = np.exp(1j*np.random.uniform(0, 2*np.pi, (nsamples, )))

    # make frequency follow 1/f law
    n[1:] = np.array(n[1:])/f[1:]

    # Add some LFP-like components
    #=== TO DO ===#

    # generate the timeseries
    s = np.real(np.fft.ifft(n))
    return s

def simulate_recording(nchans=10, nsamples=10000, fs=1000, **kwargs):
    &#34;&#34;&#34;
    Simulates an LFP recording with bursts in power of certain bands.
    &#34;&#34;&#34;

    # create empty array
    dat = np.zeros((nchans, nsamples))

    # fill array with pink noise
    for i in range(dat.shape[0]):
        dat[i,:] = generate_ts(seed=42)
    
    dat = np.repeat(dat[:, :, np.newaxis], 10, axis=-1)

    return dat
 
def test():
    &#34;&#34;&#34;
    Simple test method to ensure that the pipeline and dependencies work.
    
    Returns `True` if everything works.
    &#34;&#34;&#34;
    s = simulate_recording(seed=42)
    norm = get_norm_array(s)
    ds, f = get_stft(s, norm_array=norm)
    t, b = get_bands(ds[:,:,:,:2], ds[:,:,:,-2:], f)
    snr = get_snr(t, b)
    
    print(np.int(snr.ravel().max())==0)
    
def contrast(data, y, **kwargs):
    &#34;&#34;&#34;
    This method returns the SNR given a data array and vector of labels.
    
    Ideally, this should be the only method that you need to call when contrasting timeseries&#39; spectra.
    
    Parameters
    ----------
    data: array [nchans x nobs x ntrials]
        an array with the LFP data organized into channels and trials.
    y: array [ntrials]
        a binary vector with a label for each trial being either 0 or 1
        
    Returns
    -------
    snr: array [nfreqs x nfreqs]
        a matrix with the SNR for each combination of frequency bands
    f: array [nfreqs]
        a vector that represents the frequencies for interpreting `snr`.
    &#34;&#34;&#34;
    
    # read stft params from function arguments
    if &#39;fs&#39; in kwargs.items(): fs=kwargs[&#39;fs&#39;]
    else: fs = 1000

    if &#39;nperseg&#39; in kwargs.items(): noverlap=kwargs[&#39;nperseg&#39;]
    else: nperseg = 640

    if &#39;noverlap&#39; in kwargs.items(): noverlap=kwargs[&#39;noverlap&#39;]
    else: noverlap = 3*(nperseg//4)
    
    # convert input to numpy array (precautionarily)
    data = np.array(data)    
    
    # get normalization array
    norm = get_norm_array(data)
    
    # decompose data
    ds, f = get_stft(data, norm_array=norm)
    
    # compute mean power over every permutation of bands
    t, b = get_bands(ds[:,:,:,y==1], ds[:,:,:,y==0], f)
    
    # calculate the snr
    snr = get_snr(t, b)
    
    return snr, f

def filter(data, low_pass, high_pass, fs, order=10):
    &#34;&#34;&#34;
    Generates an n-th order butterworth filter and performs forward-backward pass on the signal.
    
    Parameters
    ----------
    data: array
        same as data structure [nchans x nobs x ntrials]
    low_pass: param
        low pass frequency
    high_pass: param
        high pass frequency
    fs: param
        sampling frequency
    order: param
        filter order
        
    Returns
    -------
    filt_data: array
        array with same shape as `data` but bandpass filtered
    &#34;&#34;&#34;

    nyq = fs/2
    low = low_pass/nyq
    high = high_pass/nyq

    b, a = signal.butter(order, [low, high], btype=&#39;band&#39;)
    filt_data = np.abs(signal.hilbert(signal.filtfilt(b, a, data, axis=1), axis=1))
    return filt_data

if __name__ == &#39;__main__&#39;:
    test()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="spectral.contrast.contrast"><code class="name flex">
<span>def <span class="ident">contrast</span></span>(<span>data, y, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>This method returns the SNR given a data array and vector of labels.</p>
<p>Ideally, this should be the only method that you need to call when contrasting timeseries' spectra.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array</code> [<code>nchans</code> <code>x</code> <code>nobs</code> <code>x</code> <code>ntrials</code>]</dt>
<dd>an array with the LFP data organized into channels and trials.</dd>
<dt><strong><code>y</code></strong> :&ensp;<code>array</code> [<code>ntrials</code>]</dt>
<dd>a binary vector with a label for each trial being either 0 or 1</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>snr</code></strong> :&ensp;<code>array</code> [<code>nfreqs</code> <code>x</code> <code>nfreqs</code>]</dt>
<dd>a matrix with the SNR for each combination of frequency bands</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code> [<code>nfreqs</code>]</dt>
<dd>a vector that represents the frequencies for interpreting <code>snr</code>.</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def contrast(data, y, **kwargs):
    &#34;&#34;&#34;
    This method returns the SNR given a data array and vector of labels.
    
    Ideally, this should be the only method that you need to call when contrasting timeseries&#39; spectra.
    
    Parameters
    ----------
    data: array [nchans x nobs x ntrials]
        an array with the LFP data organized into channels and trials.
    y: array [ntrials]
        a binary vector with a label for each trial being either 0 or 1
        
    Returns
    -------
    snr: array [nfreqs x nfreqs]
        a matrix with the SNR for each combination of frequency bands
    f: array [nfreqs]
        a vector that represents the frequencies for interpreting `snr`.
    &#34;&#34;&#34;
    
    # read stft params from function arguments
    if &#39;fs&#39; in kwargs.items(): fs=kwargs[&#39;fs&#39;]
    else: fs = 1000

    if &#39;nperseg&#39; in kwargs.items(): noverlap=kwargs[&#39;nperseg&#39;]
    else: nperseg = 640

    if &#39;noverlap&#39; in kwargs.items(): noverlap=kwargs[&#39;noverlap&#39;]
    else: noverlap = 3*(nperseg//4)
    
    # convert input to numpy array (precautionarily)
    data = np.array(data)    
    
    # get normalization array
    norm = get_norm_array(data)
    
    # decompose data
    ds, f = get_stft(data, norm_array=norm)
    
    # compute mean power over every permutation of bands
    t, b = get_bands(ds[:,:,:,y==1], ds[:,:,:,y==0], f)
    
    # calculate the snr
    snr = get_snr(t, b)
    
    return snr, f</code></pre>
</details>
</dd>
<dt id="spectral.contrast.filter"><code class="name flex">
<span>def <span class="ident">filter</span></span>(<span>data, low_pass, high_pass, fs, order=10)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates an n-th order butterworth filter and performs forward-backward pass on the signal.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array</code></dt>
<dd>same as data structure [nchans x nobs x ntrials]</dd>
<dt><strong><code>low_pass</code></strong> :&ensp;<code>param</code></dt>
<dd>low pass frequency</dd>
<dt><strong><code>high_pass</code></strong> :&ensp;<code>param</code></dt>
<dd>high pass frequency</dd>
<dt><strong><code>fs</code></strong> :&ensp;<code>param</code></dt>
<dd>sampling frequency</dd>
<dt><strong><code>order</code></strong> :&ensp;<code>param</code></dt>
<dd>filter order</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>filt_data</code></strong> :&ensp;<code>array</code></dt>
<dd>array with same shape as <code>data</code> but bandpass filtered</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def filter(data, low_pass, high_pass, fs, order=10):
    &#34;&#34;&#34;
    Generates an n-th order butterworth filter and performs forward-backward pass on the signal.
    
    Parameters
    ----------
    data: array
        same as data structure [nchans x nobs x ntrials]
    low_pass: param
        low pass frequency
    high_pass: param
        high pass frequency
    fs: param
        sampling frequency
    order: param
        filter order
        
    Returns
    -------
    filt_data: array
        array with same shape as `data` but bandpass filtered
    &#34;&#34;&#34;

    nyq = fs/2
    low = low_pass/nyq
    high = high_pass/nyq

    b, a = signal.butter(order, [low, high], btype=&#39;band&#39;)
    filt_data = np.abs(signal.hilbert(signal.filtfilt(b, a, data, axis=1), axis=1))
    return filt_data</code></pre>
</details>
</dd>
<dt id="spectral.contrast.generate_ts"><code class="name flex">
<span>def <span class="ident">generate_ts</span></span>(<span>nsamples=10000, fs=1000, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Generates a 10s long LFP-like timeseries at 1kHz obeying the power law.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def generate_ts(nsamples=10000, fs=1000, **kwargs):
    &#34;&#34;&#34;
    Generates a 10s long LFP-like timeseries at 1kHz obeying the power law.
    &#34;&#34;&#34;
    # For unit test
    if &#39;seed&#39; in kwargs.items(): np.random.seed=kwargs[&#39;seed&#39;]
   
    # Generate some pink noise
    t = np.arange(nsamples) # timesteps
    f = 2*np.pi*t/fs  # frequency (in radians)

    # generate random complex series
    n = np.zeros((nsamples,), dtype=complex)
    n = np.exp(1j*np.random.uniform(0, 2*np.pi, (nsamples, )))

    # make frequency follow 1/f law
    n[1:] = np.array(n[1:])/f[1:]

    # Add some LFP-like components
    #=== TO DO ===#

    # generate the timeseries
    s = np.real(np.fft.ifft(n))
    return s</code></pre>
</details>
</dd>
<dt id="spectral.contrast.get_bands"><code class="name flex">
<span>def <span class="ident">get_bands</span></span>(<span>target_stft_norm, baseline_stft_norm, f)</span>
</code></dt>
<dd>
<section class="desc"><p>Calculates the mean power across all possible combinations of frequencies for each channel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>target_stft_norm</code></strong> :&ensp;<code>array</code></dt>
<dd>stft decomposed target array [nchan x nfreqs x nobs x ntrials]</dd>
<dt><strong><code>baseline_stft_norm</code></strong> :&ensp;<code>array</code></dt>
<dd>stft decomposed baseline array [nchan x nfreqs x nobs x ntrials]</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code></dt>
<dd>vector of frequencies obtained from STFT transform (see <a title="spectral.contrast.get_stft" href="#spectral.contrast.get_stft"><code>get_stft()</code></a>).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>target_bands</code></strong> :&ensp;<code>array</code></dt>
<dd>array of mean power across all possible band permutations [nchan x nfreqs x nfreqs x nobs x ntrials]</dd>
<dt><strong><code>baseline_bands</code></strong> :&ensp;<code>array</code></dt>
<dd>same as <code>target_bands</code> [nchan x nfreqs x nfreqs x nobs x ntrials]</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_bands(target_stft_norm, baseline_stft_norm, f):
    &#34;&#34;&#34;
    Calculates the mean power across all possible combinations of frequencies for each channel.
    
    Parameters
    ----------
    target_stft_norm: array
        stft decomposed target array [nchan x nfreqs x nobs x ntrials]
    baseline_stft_norm: array
        stft decomposed baseline array [nchan x nfreqs x nobs x ntrials]
    f: array
        vector of frequencies obtained from STFT transform (see `get_stft()`).
    
    Returns
    -------
    target_bands: array
        array of mean power across all possible band permutations [nchan x nfreqs x nfreqs x nobs x ntrials]
    baseline_bands: array
        same as `target_bands` [nchan x nfreqs x nfreqs x nobs x ntrials]
    &#34;&#34;&#34;
    
    data_array_norm = target_stft_norm
    baseline_array_norm = baseline_stft_norm

    fmax = 500
    fidx = f &lt; fmax
    fnum = f[fidx].size

    band_tot = np.zeros((fnum, fnum, data_array_norm.shape[0], data_array_norm.shape[2], data_array_norm.shape[3]))
    band_tot_bl = np.zeros((fnum, fnum, baseline_array_norm.shape[0], baseline_array_norm.shape[2], baseline_array_norm.shape[3]))
    for i in range(fnum):
        for j in range(fnum):
            if j &gt; i:
                idx = (f &gt;= f[i]) &amp; (f &lt; f[j])
                band_tot[i, j, :, :] = np.sum(data_array_norm[:, idx, :, :], axis=1) / (f[j] - f[i])
                band_tot_bl[i, j, :, :] = np.sum(baseline_array_norm[:, idx, :, :], axis=1) / (f[j] - f[i])


    band_tot_bl1 = np.mean(band_tot_bl, axis=3)     # average across time bins
    band_tot_bl2 = np.repeat(band_tot_bl1[:, :, :, None, :], band_tot_bl.shape[3], axis=3)    # repeat same value across time
    return band_tot, band_tot_bl2</code></pre>
</details>
</dd>
<dt id="spectral.contrast.get_norm_array"><code class="name flex">
<span>def <span class="ident">get_norm_array</span></span>(<span>data, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the normalization array for timeseries data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data</code></strong> :&ensp;<code>array</code>, <code>timeseries</code> <code>data</code> [<code>nchan</code> <code>x</code> <code>nobs</code> <code>x</code> <code>ntrials</code>]</dt>
<dd>&nbsp;</dd>
<dt><strong><code>*fs</code></strong> :&ensp;<code>int</code>, <code>sampling</code> <code>frequency</code> <code>in</code> <code>Hz</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>*nperseg</code></strong> :&ensp;<code>int</code>, <code>number</code> of <code>timepoints</code> <code>for</code> <code>stft</code> <code>window</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>*noverlap</code></strong> :&ensp;<code>int</code>, <code>number</code> of <code>timepoints</code> <code>for</code> <code>window</code> <code>overlap</code></dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>norm_array</code></strong> :&ensp;<code>normalized</code> <code>array</code> <code>with</code> <code>mean</code> <code>power</code> <code>per</code> <code>frequency</code> [<code>nchan</code> <code>x</code> <code>freqs</code>]</dt>
<dd>&nbsp;</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_norm_array(data, **kwargs):
    &#34;&#34;&#34;
    Returns the normalization array for timeseries data.
    
    Parameters
    ----------
    data: array, timeseries data [nchan x nobs x ntrials]
    *fs: int, sampling frequency in Hz
    *nperseg: int, number of timepoints for stft window
    *noverlap: int, number of timepoints for window overlap

    Returns
    -------
    norm_array: normalized array with mean power per frequency [nchan x freqs]
    &#34;&#34;&#34;

    # Read stft params from function arguments
    if &#39;fs&#39; in kwargs.items(): fs=kwargs[&#39;fs&#39;]
    else: fs = 1000

    if &#39;nperseg&#39; in kwargs.items(): noverlap=kwargs[&#39;nperseg&#39;]
    else: nperseg = 64

    if &#39;noverlap&#39; in kwargs.items(): noverlap=kwargs[&#39;noverlap&#39;]
    else: noverlap = 3*(nperseg//4)

    # Get the STFT of the signals
    f, _, data_stft = signal.stft(
        data, fs=fs, nperseg=nperseg, noverlap=noverlap, axis=1)

    data_stft = np.moveaxis(np.abs(data_stft), 2, 3)  # last axis is now ntrials
    data_stft = data_stft[:, :, 1:-1, :]              # purge STFT flanks

    # Average across trials and time-bins
    data_stft_mean = np.mean(np.abs(data_stft), axis=-1)    # trials
    norm_array = np.mean(np.abs(data_stft_mean), axis=-1)   # timebins

    return norm_array</code></pre>
</details>
</dd>
<dt id="spectral.contrast.get_snr"><code class="name flex">
<span>def <span class="ident">get_snr</span></span>(<span>target, baseline)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the SNR given two vectors: target and baseline.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>target</code></strong> :&ensp;<code>array</code> [<code>nchan</code> <code>x</code> <code>nfreqs</code> <code>x</code> <code>nfreqs</code> <code>x</code> <code>nobs</code> <code>x</code> <code>ntrials</code>]</dt>
<dd>an array obtained by using <a title="spectral.contrast.get_bands" href="#spectral.contrast.get_bands"><code>get_bands()</code></a></dd>
<dt><strong><code>baseline</code></strong> :&ensp;<code>array</code> (<code>same</code> <code>as</code> <code>target</code>)</dt>
<dd>&nbsp;</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>snr</code></strong> :&ensp;<code>array</code> [<code>nfreqs</code> <code>x</code> <code>nfreqs</code>]</dt>
<dd>a lower triangular matix representing the contrast between bands</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_snr(target, baseline):
    &#34;&#34;&#34;
    Returns the SNR given two vectors: target and baseline.
    
    Parameters
    ----------
    target: array [nchan x nfreqs x nfreqs x nobs x ntrials]
        an array obtained by using `get_bands()`
    
    baseline: array (same as target)

    Returns
    -------
    snr: array [nfreqs x nfreqs]
        a lower triangular matix representing the contrast between bands
    &#34;&#34;&#34;

    mu_cue = np.mean(target, axis=-1)     # average accross trials
    mu_bl = np.mean(baseline, axis=-1)     # average accross trials
    std_cue = np.std(target, axis=-1)     # average accross trials
    std_bl = np.std(baseline, axis=-1)     # average accross trials

    snr = np.abs(_div0((mu_cue - mu_bl), (std_cue + std_bl)))
    snr2 = np.nanmax(snr, axis=-1)
    if snr2.shape[0] == snr.shape[1]:
        snr2 = np.nanmax(snr2, axis=-1)

    return snr2</code></pre>
</details>
</dd>
<dt id="spectral.contrast.get_stft"><code class="name flex">
<span>def <span class="ident">get_stft</span></span>(<span>data_array, norm_array=[], normalize=True, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Returns the STFT for timeseries data.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>data_array</code></strong> :&ensp;<code>array</code></dt>
<dd>timeseries data [nchan x nobs x ntrials]</dd>
<dt><strong><code>norm_array</code></strong> :&ensp;<code>array</code></dt>
<dd>for spectral normalization (see <a title="spectral.contrast.get_norm_array" href="#spectral.contrast.get_norm_array"><code>get_norm_array()</code></a>)</dd>
<dt><strong><code>*fs</code></strong> :&ensp;<code>int</code></dt>
<dd>sampling frequency in Hz</dd>
<dt><strong><code>*nperseg</code></strong> :&ensp;<code>int</code></dt>
<dd>number of timepoints for stft window</dd>
<dt><strong><code>*noverlap</code></strong> :&ensp;<code>int</code></dt>
<dd>number of timepoints for window overlap</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>stft_array</code></strong> :&ensp;<code>array</code></dt>
<dd>STFT of the input array [nchan x nfreqs x nobs x trials]</dd>
<dt><strong><code>f</code></strong> :&ensp;<code>array</code></dt>
<dd>an array of the frequencies of the STFT transform</dd>
</dl></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_stft(data_array, norm_array=[], normalize=True, **kwargs):
    &#34;&#34;&#34;
    Returns the STFT for timeseries data.
    
    Parameters
    -----------
    data_array: array
        timeseries data [nchan x nobs x ntrials]
    norm_array: array
        for spectral normalization (see `get_norm_array()`)
    *fs: int
        sampling frequency in Hz
    *nperseg: int
        number of timepoints for stft window
    *noverlap: int
        number of timepoints for window overlap
        
    Returns
    -------
    stft_array: array
        STFT of the input array [nchan x nfreqs x nobs x trials]
    f: array
        an array of the frequencies of the STFT transform
    &#34;&#34;&#34;
    # Read stft params from function arguments
    if &#39;fs&#39; in kwargs.items(): fs=kwargs[&#39;fs&#39;]
    else: fs = 1000

    if &#39;nperseg&#39; in kwargs.items(): noverlap=kwargs[&#39;nperseg&#39;]
    else: nperseg = 64

    if &#39;noverlap&#39; in kwargs.items(): noverlap=kwargs[&#39;noverlap&#39;]
    else: noverlap = 3*(nperseg//4)

    # Calculate the short-time fourrier transform
    f, _, data_stft = signal.stft(
        data_array, fs=fs, nperseg=nperseg, noverlap=noverlap, axis=1)
    
    # Make last axis as trials
    data_stft = np.moveaxis(np.abs(data_stft), 2, 3)
    data_stft = data_stft[:,:,1:-1,:]

    if normalize:
        # Facilitate vectorized division
        norm_array_data = np.repeat(norm_array[:, :, np.newaxis], data_stft.shape[-2], axis=-1)
        norm_array_data = np.repeat(norm_array_data[:, :, :, np.newaxis], data_stft.shape[-1], axis=-1)

        # Normalize the spectrograms for calculating SNR
        data_stft_norm = data_stft / norm_array_data

        return data_stft_norm, f

    else:
        return data_stft, f</code></pre>
</details>
</dd>
<dt id="spectral.contrast.simulate_recording"><code class="name flex">
<span>def <span class="ident">simulate_recording</span></span>(<span>nchans=10, nsamples=10000, fs=1000, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Simulates an LFP recording with bursts in power of certain bands.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def simulate_recording(nchans=10, nsamples=10000, fs=1000, **kwargs):
    &#34;&#34;&#34;
    Simulates an LFP recording with bursts in power of certain bands.
    &#34;&#34;&#34;

    # create empty array
    dat = np.zeros((nchans, nsamples))

    # fill array with pink noise
    for i in range(dat.shape[0]):
        dat[i,:] = generate_ts(seed=42)
    
    dat = np.repeat(dat[:, :, np.newaxis], 10, axis=-1)

    return dat</code></pre>
</details>
</dd>
<dt id="spectral.contrast.test"><code class="name flex">
<span>def <span class="ident">test</span></span>(<span>)</span>
</code></dt>
<dd>
<section class="desc"><p>Simple test method to ensure that the pipeline and dependencies work.</p>
<p>Returns <code>True</code> if everything works.</p></section>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test():
    &#34;&#34;&#34;
    Simple test method to ensure that the pipeline and dependencies work.
    
    Returns `True` if everything works.
    &#34;&#34;&#34;
    s = simulate_recording(seed=42)
    norm = get_norm_array(s)
    ds, f = get_stft(s, norm_array=norm)
    t, b = get_bands(ds[:,:,:,:2], ds[:,:,:,-2:], f)
    snr = get_snr(t, b)
    
    print(np.int(snr.ravel().max())==0)</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="spectral" href="index.html">spectral</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="spectral.contrast.contrast" href="#spectral.contrast.contrast">contrast</a></code></li>
<li><code><a title="spectral.contrast.filter" href="#spectral.contrast.filter">filter</a></code></li>
<li><code><a title="spectral.contrast.generate_ts" href="#spectral.contrast.generate_ts">generate_ts</a></code></li>
<li><code><a title="spectral.contrast.get_bands" href="#spectral.contrast.get_bands">get_bands</a></code></li>
<li><code><a title="spectral.contrast.get_norm_array" href="#spectral.contrast.get_norm_array">get_norm_array</a></code></li>
<li><code><a title="spectral.contrast.get_snr" href="#spectral.contrast.get_snr">get_snr</a></code></li>
<li><code><a title="spectral.contrast.get_stft" href="#spectral.contrast.get_stft">get_stft</a></code></li>
<li><code><a title="spectral.contrast.simulate_recording" href="#spectral.contrast.simulate_recording">simulate_recording</a></code></li>
<li><code><a title="spectral.contrast.test" href="#spectral.contrast.test">test</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.7.2</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>